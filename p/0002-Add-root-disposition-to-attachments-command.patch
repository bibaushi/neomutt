From 3b9cc43f5f91eae11e90f2f713576358f2264a23 Mon Sep 17 00:00:00 2001
From: Kevin McCarthy <kevin@8t8.us>
Date: Thu, 2 Apr 2020 14:30:08 -0700
Subject: [PATCH 02/19] Add "root" disposition to attachments command.

An initial inline part was previously always skipped, for the good
reasons outlined by @dgc in #217.

Unfortunately, some mail clients have started sending "attachments" as
the root (and only) part, more and more lately.  Although this may be
bad practice, Mutt should support counting these as "attachments".

To do so without breaking existing configs, add a "root" disposition
argument to the attachments command.  This will count an initial
inline part in a message or multipart container.

The existing code skipped counting for the "top-level" and recursive
calls, so group both of these cases under "root".
---
 doc/manual.xml.head |  7 +++++++
 globals.h           |  2 ++
 init.c              | 18 ++++++++++++++++++
 parse.c             | 25 ++++++++++++++++---------
 4 files changed, 43 insertions(+), 9 deletions(-)

diff --git a/doc/manual.xml.head b/doc/manual.xml.head
index cd0efa18..1ece5904 100644
--- a/doc/manual.xml.head
+++ b/doc/manual.xml.head
@@ -8393,6 +8393,13 @@ type &mdash; either <literal>inline</literal> or
 <literal>I</literal> or <literal>A</literal>.
 </para>
 
+<para>
+A first (or only) inline part of a message or multipart is considered
+a <quote>root</quote> part, and is counted separately than other
+inline parts.  Specify <literal>root</literal> or <literal>R</literal>
+for <emphasis>disposition</emphasis> to count these as attachments.
+</para>
+
 <para>
 Disposition is prefixed by either a <quote>+</quote> symbol or a
 <quote>-</quote> symbol.  If it's a <quote>+</quote>, you're saying that
diff --git a/globals.h b/globals.h
index 8218e2d8..ec31f6b7 100644
--- a/globals.h
+++ b/globals.h
@@ -189,6 +189,8 @@ WHERE LIST *AttachAllow;
 WHERE LIST *AttachExclude;
 WHERE LIST *InlineAllow;
 WHERE LIST *InlineExclude;
+WHERE LIST *RootAllow;
+WHERE LIST *RootExclude;
 WHERE LIST *HeaderOrderList;
 WHERE LIST *Ignore;
 WHERE LIST *MailtoAllow;
diff --git a/init.c b/init.c
index 6cde7d0f..26f8afcf 100644
--- a/init.c
+++ b/init.c
@@ -1316,6 +1316,8 @@ static int parse_attachments (BUFFER *buf, BUFFER *s, union pointer_long_t udata
     print_attach_list(AttachExclude, '-', "A");
     print_attach_list(InlineAllow,   '+', "I");
     print_attach_list(InlineExclude, '-', "I");
+    print_attach_list(RootAllow,     '+', "R");
+    print_attach_list(RootExclude,   '-', "R");
     mutt_any_key_to_continue (NULL);
     return 0;
   }
@@ -1339,6 +1341,13 @@ static int parse_attachments (BUFFER *buf, BUFFER *s, union pointer_long_t udata
     else
       listp = &InlineExclude;
   }
+  else if (!ascii_strncasecmp(category, "root", strlen(category)))
+  {
+    if (op == '+')
+      listp = &RootAllow;
+    else
+      listp = &RootExclude;
+  }
   else
   {
     strfcpy(err->data, _("attachments: invalid disposition"), err->dsize);
@@ -1381,6 +1390,8 @@ static int parse_unattachments (BUFFER *buf, BUFFER *s, union pointer_long_t uda
       mutt_free_list_generic(&AttachExclude, free_attachments_data);
       mutt_free_list_generic(&InlineAllow, free_attachments_data);
       mutt_free_list_generic(&InlineExclude, free_attachments_data);
+      mutt_free_list_generic(&RootAllow, free_attachments_data);
+      mutt_free_list_generic(&RootExclude, free_attachments_data);
       _attachments_clean();
       return 0;
   }
@@ -1404,6 +1415,13 @@ static int parse_unattachments (BUFFER *buf, BUFFER *s, union pointer_long_t uda
     else
       listp = &InlineExclude;
   }
+  else if (!ascii_strncasecmp(p, "root", strlen(p)))
+  {
+    if (op == '+')
+      listp = &RootAllow;
+    else
+      listp = &RootExclude;
+  }
   else
   {
     strfcpy(err->data, _("unattachments: invalid disposition"), err->dsize);
diff --git a/parse.c b/parse.c
index a2c09424..52004408 100644
--- a/parse.c
+++ b/parse.c
@@ -1755,10 +1755,6 @@ static int count_body_parts (BODY *body, int flags)
 	AT_NOCOUNT("top-level multipart");
     }
 
-    if (bp->disposition == DISPINLINE &&
-        bp->type != TYPEMULTIPART && bp->type != TYPEMESSAGE && bp == body)
-      AT_NOCOUNT("ignore fundamental inlines");
-
     /* If this body isn't scheduled for enumeration already, don't bother
      * profiling it further.
      */
@@ -1778,10 +1774,20 @@ static int count_body_parts (BODY *body, int flags)
       }
       else
       {
-        if (!count_body_parts_check(&InlineAllow, bp, 1))
-	  AT_NOCOUNT("inline not allowed");
-        if (count_body_parts_check(&InlineExclude, bp, 0))
-	  AT_NOCOUNT("excluded");
+        if (bp == body)
+        {
+          if (!count_body_parts_check(&RootAllow, bp, 1))
+            AT_NOCOUNT("root not allowed");
+          if (count_body_parts_check(&RootExclude, bp, 0))
+            AT_NOCOUNT("root excluded");
+        }
+        else
+        {
+          if (!count_body_parts_check(&InlineAllow, bp, 1))
+            AT_NOCOUNT("inline not allowed");
+          if (count_body_parts_check(&InlineExclude, bp, 0))
+            AT_NOCOUNT("excluded");
+        }
       }
     }
 
@@ -1816,7 +1822,8 @@ int mutt_count_body_parts (CONTEXT *ctx, HEADER *hdr)
   else
     mutt_parse_mime_message (ctx, hdr);
 
-  if (AttachAllow || AttachExclude || InlineAllow || InlineExclude)
+  if (AttachAllow || AttachExclude || InlineAllow || InlineExclude ||
+      RootAllow || RootExclude)
     hdr->attach_total = count_body_parts(hdr->content, MUTT_PARTS_TOPLEVEL);
   else
     hdr->attach_total = 0;
